#!/usr/bin/perl

srand(time());

print '#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "hd_private.h"

extern int strcmp(char*,char*);

/*
 * This file has been generated by hell.pl and tests the hashdisk library.
 */

int main(int argc, char* argv[]) {
  int fd = open("/tmp/foo", O_RDWR|O_CREAT|O_TRUNC, 0664);
  if (fd >= 0) {
    hd_t hd;
    {
      char buf[1024];
      memset(buf, 0, 1024);
      write(fd, buf, 1024);
    }
    hd_init_fd(&hd, HDFLG_DUPLKEYS|HDFLG_EXTEND, fd);
';

my %hash; ## The shadow structure of our hash.
my $nentries = 0;

for (my $i=0; $i<100; $i++) {
  my $action = int(rand(5));

  ## DEL
  if ($action == 0) {
    my @keys = keys(%hash);
    my $n = scalar(@keys);
    if ($n == 0) {
      $action = int(rand(4))+1;
    } else {
      my $key = $keys[ int(rand($n)) ];
      my $values = $hash{$key};
      do_del($key, $values);
      delete $hash{$key};
    }
  }

  ## GET
  if ($action == 1 || $action == 2) {
    my @keys = keys(%hash);
    my $n = scalar(@keys);
    if ($n == 0) {
      $action = 4;
    } else {
      my $key = $keys[ int(rand($n)) ];
      my $values = $hash{$key};
      print '
    fprintf(stderr, "get '.$key.'; expect one of '.join(', ', @{$values}).'\n");
    {
      hdt_t key = hdt_string(0, "'.$key.'");
      char mem[100];
      hdt_t value = { mem, 100 };
      memset(mem, 0, 100);
      int r = hd_get(&hd, &key, &value);
      if (r) {
        fprintf(stderr, "Got code %d\n", r);
        return ~0;
      }
      if (strcmp(value.data, "' .
        join('") && strcmp(value.data, "', @{$values}) . '")) {
        fprintf(stderr, "Got \'%s\' instead.\n", (char*)(value.data));
        return ~0;
      }
    }
';
    }
  }

  ## PUT
  if ($action == 3 || $action == 4) {
    my $occurence = rand(3);
    my $keysize = rand(20) + 3;
    my $key = '';
    for (my $k=0; $k<$keysize; $k++) {
      $key .= ( 'a' .. 'z', 'A' .. 'Z' )[ rand(52) ];
    }
    for (my $o=0; $o<$occurence; $o++) {
      my $valuesize = rand(60) + 20;
      my $value = '';
      for (my $v=0; $v<$valuesize; $v++) {
        $value .= ( 'a' .. 'z', 'A' .. 'Z' )[ rand(52) ];
      }
      ++$nentries;
      print '
    fprintf(stderr, "put '.$key.' -> '.$value.'\n");
    {
      hdt_t key = hdt_string(0, "'.$key.'"),
            value = hdt_string(0, "'.$value.'");
      int r;
      if ((r = hd_put(&hd, &key, &value, 0)) != 0) {
        hd_write_header(&hd);
        hd_debug(&hd);
        fprintf(stderr, "Put failed with code %d\n", r);
        return ~0;
      }
      if (hd.header.nentries != '.$nentries.') {
        fprintf(stderr, "Number of entries is incorrect; exp '.$nentries.'.\n");
      }
      hd_debug(&hd);
    }
';
      my $exist = $hash{$key};
      push @{$exist}, $value;
      $hash{$key} = $exist;
    }
  }
}

my @keys = keys(%hash);
foreach my $key (@keys) {
  my $values = $hash{$key};
  do_del($key, $values);
  delete $hash{$key};
}

sub do_del {
  my ($key, $values) = @_;
  $nentries -= scalar(@{$values});
  print '
    fprintf(stderr, "del '.$key.' '.scalar(@{$values}).' times\n");
    {
      int i=0;
      for (; i<' . scalar(@{$values}) . '; i++) {
        hdt_t key = hdt_string(0, "'.$key.'");
        char mem[100];
        hdt_t value = { mem, 100 };
        memset(mem, 0, 100);
        int r = hd_del(&hd, &key, &value);
        if (r) {
          fprintf(stderr, "Got code %d\n", r);
          return ~0;
        }
      }
    }
    {
      hdt_t key = hdt_string(0, "'.$key.'");
      char mem[100];
      hdt_t value = { mem, 100 };
      memset(mem, 0, 100);
      int r = hd_del(&hd, &key, &value);
      if (r != HDERR_NOTFOUND) {
        fprintf(stderr, "Delete; key should be empty.\n");
        return ~0;
      }
    }
    if (hd.header.nentries != '.$nentries.') {
      fprintf(stderr, "Number of entries is incorrect; got %d, exp '.
      $nentries.'.\n", hd.header.nentries);
      return ~0;
    }
    hd_debug(&hd);
';
}

print '
    if (hd.header.nentries != 0) {
      fprintf(stderr, "At the end; entries != 0\n");
      return ~0;
    }
    hd_debug(&hd);
  }
  unlink("/tmp/foo");
  return 0;
}
';

1;
